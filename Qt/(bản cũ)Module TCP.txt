# TCP:

-> Basic:
Server mà ta đã dùng k được áp dụng trong thực tế. Nguyên nhân là vì ta dùng sai, trong javascript họ cũng tư duy như v->đó là mỗi connection 1 thread. 
Ta biết cái thread là 1 thứ rất đắt trong Ct, tài nguyên ở CPU lấy ra dùng cho thread có giới hạn. Do đó các server trong thực tế, họ chạy multithread và mỗi thread lại chạy multi-connection.
Nếu k, giả sử CPU chỉ cho ta sử dụng max là 5 thread, or ta set max thread count là 5 cho thread pool-> nếu có 10 connection thì 5 connection sau sẽ đi vào hàng đợi và phải chờ 5 thg kia kết thúc. Nếu dùng chuẩn thì ta chỉ cần 5 thread đó nhưng mỗi thread lại quản lý hàng trăm connection cơ. 
Đó cũng là cách giải quyết vấn đề C10K-> vấn đề 1 server quản lý 10k connection trong 1 lúc=> đương nhiên k thể tạo 10k thread đc(tùy CPU và RAM). 1 thread xử lý nhiều connection, đó là cách mà các web server nổi tiếng như Apache Server xử lý vấn đề C10K. Bài toán C10K bh đã lên tới hàng triệu 1 connection 1 lúc. Họ k có CPU có pool of hàng triệu thread nhưng họ vẫn có thể xử lý hàng triệu connection.

Để làm đc điều đó phải có giới hạn, ví dụ 1 cái thread của server cho phép 1 client với tốc độ tối đa. Nhưng để dùng 1 thread đó cho multiconnection thì mỗi connection k thể tối đa được mà phải giảm xuống. Ví dụ tốc độ load của client khi kết nối với server max là 1GB/1s nhưng để dùng multithread thì tốc độ chỉ còn là 10MB/1s. Người ta sẽ setup cái giới hạn đó cho mỗi client khi kết nối với server để đảm bảo có thể phục vụ cho 1 số lượng client đủ lớn. Bên trong cái thread chạy asynchronous nên sẽ thực hiện chuyển đổi liên tục xử lý mỗi cái 1 tí theo cơ chế asynchronous chứ k còn xử lý 1 cái nx nên tốc độ xử lý từng cái sẽ giảm dần đi. Vc set max dung lượng sẽ khiến dù server có ít connection đến mấy vẫn ko thể vượt quá đc tốc độ đó. Đến khi TH có quá nhiều connection kết nối cùng 1 lúc vượt qua sự tính toán rằng "mỗi cái 10MB/1s là ổn", khi đó tốc độ của mỗi connection có thể dưới cả 10MB/1s nên ta mới thấy kết nối với cái server này chậm hơn bth.
Như ta đã biết, lập trình multithread asynchronous sẽ do máy tự tính toán. Ví dụ: có max 2 thread a và b đang xử lý 2 công vc, ta muốn thêm 1 công vc thứ 3 thì máy sẽ tự tìm rằng thread đó cái nào rảnh hơn thì sẽ nhét vào thread đó, nó cx tự xử lý trong 1 cái thread có nhiều công vc rằng công vc nào đang trong TT rảnh sẽ thực hiện công vc kia, công vc nào thread cần thực hiện tiếp để sao cho thread đó luôn trong TT làm vc và các cv đc hoàn thành với tốc độ tối ưu. Đó là cơ chế máy xử lý mà ta có học qua trong môn intro. CV của lập trình viên chỉ là set cho Ct chạy multithread asynchronous để nhét CV2 vào thread, còn lại máy tính lo hết.

Cái threadpool+runnable trong cái multithread server của ta cho phép người dùng dùng asynchronous, tức là cái thread đó của ta có thể làm thêm nhiều công vc khác đồng thời khi công vc này có lúc rảnh, nhưng ta lại cho nó cứ mỗi khi có 1 connection mới, thì threadpool lại phải nhả ra 1 thread mới cho nó. Điều này khiến cho thread đó chỉ có 1 nhiệm vụ là xử lý 1 cái connection đó thôi. Xong khi có connection mới thì threadpool full chẳng hạn thì nó sẽ đi vào hàng chờ cái thread kia xong=>tức là threadpool cung cho ta asynchronous và ta có thể dùng 1 thread đó để làm nhiều vc. Thế mà ta lại chỉ dùng thread đó để quản lý mỗi 1 cái connection thì có khác gì synchronous đâu=> cái server đó là sai và k khả thi trong thực tế.

Khi có quá nhiều client thì 1 server đơn lẻ k đáp ứng được lượng request khổng lồ-> ng ta sẽ dùng Ct đó với multiserver, VD: facebook có rất nhiều máy chủ trên thế giới. Họ dùng 1 cái load balancer có vai trò phân phối lưu lượng đến 1 nhóm backend server(server pool). Vs cơ chế tương tự, nó tự tính toán xem với yêu cầu mới thêm vào thì server nào sẽ thực hiện để k có server nào bị quá tải và tối ưu về tốc độ và hiệu suất. Nó cx xử lý đc khi 1 máy chủ bị hỏng sẽ chuyển lưu lượng sang các máy chủ còn lại, or 1 máy chủ mới đc thêm vào pool thì sẽ tính toán và sử dụng nó.VD:Cân bằng tải được sử dụng khi website được triển khai trên nhiều hơn một cloud server.

Trong Linux nó coi socket, stdin, stdout, stderr, file đều là file. Và nó giới hạn số lượng file có thể mở(kiểm tra bằng lệnh: ulimit -n) ở 1 con số khá nhỏ tùy vào cấu hình(có thể điều chỉnh)=> nếu ta dùng server với linux thì số lượng socket nó giới hạn chính là số file đó - đi số file đang mở. Để phân biệt giữa các file dùng file descriptor là số nguyên duy nhất được quản lý bởi kernel. 
Tuy nhiên trong window thì số lượng connection có thể tạo là lớn gấp nhiều lần linux, k xét lượng thread mà là lượng tối đa của connection, 1 thread có thể handle nh connection. Đó là do window dùng 1 thứ gọi là IO completion port. Nó là 1 fast and nice model. Vs nó, window quản lý tốt hơn: Nếu ta set 1 số lượng thread vào 1 IO completion port->thì khi có event tới, nó cái port đó sẽ lấy ra 1 thread đc set và xử lý cái event với giới hạn do ta set, nếu k nó sẽ lấy max là số lượng CPU cores. Nếu số lượng thread vượt quá giới hạn thì nó sẽ đợi khi nào có rảnh thì thực hiện. Nhờ IOCP mà xử lý đc vấn đề 1 thread xử lý nh client. Nói chung là nó giúp window xử lý multiple asynchronous IO request. Nó cx là đi với giới hạn socket và file có thể handle nhưng có hàng đợi và mở đc nhiều hơn linux.

mime type(Multipurpose Internet Mail Extensions): là loại giúp phân loại các tập tin sử dụng trên internet. VD: lúc mới ra đời, thư điện tử chỉ hỗ trợ gửi plaintext, họ dùng mime type là phần mở rộng cho phép email có thể gửi nhận các file có định dạng như video, audio, HTML,.. Hầu hết mọi thư điện tử đều dùng giao thức SMTP theo định dạng MIME. Nhưng ngày nay k chỉ dùng với email, nó cũng dùng trong các máy chủ và trình duyệt để xử lý thông tin. Mime type sẽ giúp specific là loại file gì, vd docx hay jpg,.. VD: ta viết một vài lá thư gửi đi, nhưng mỗi lá thư viết 1 ngôn ngữ khác nhau, mime type sẽ đính vào đầu mỗi lá thư vd "Tiếng Pháp" thì người nhận(client) sẽ nhanh chóng dịch được lá thư đó. VD: khi ta dùng ảnh jpg hay 1 vid cho website bị lỗi mặc dù file vẫn tồn tại trên server=>nguyen nhân chính là do server chưa thêm các mime type của các kiểu dữ liệu đó nên đọc k đc=>server http của ta cần có cac mimetype.
Thành phần mime type gồm: kiểu chính và kiểu phụ. Kiểu chính trước dấu /, kiểu phụ sau dấu đó phù hợp với các định dạng extension tương ứng
VD: text/plain txt thì text kiểu chính còn plain kiểu phụ với file định dạng .txt
Ta cần xác định file ta gửi có các định dạng nào và thêm vào các mime type phù hợp, k có thì Ct k đọc đc. Khi xử lý ta cũng kiểm tra nếu k có thì có thể gửi application/octet-stream là 1 file chứa dữ liệu nhị phân-1 kiểu mimetype mặc định-> Trong Ct này ta dùng mime type chỉ để lấy type của file gửi.

=>Cách xử lý hiểu những thứ phức tạp là hiểu đc cái luồng thô sơ nhất rằng mọi thứ là lý tưởng, bỏ qua mọi lỗi lặt vặt thì sẽ code rất rất dễ. Ta phải hiểu được bản chất chỉ cần cái gì để làm cái gì mà bỏ qua các cái lặt vặt khác. Đó cx là quy trình làm để hiểu mọi thứ, các thứ lặt vặt như lỗi này lỗi nọ cx chỉ là sau đó ta thêm vào thôi. Đó là kỹ năng đọc code, 1 Ct lớn nhưng ta nhìn ra ngay mấu chốt vấn đề và bỏ qua các thứ kiểm tra lặt vặt.

HTTP/1.1 là version

Cơ chế: khi ta dùng browser để truy cập vào server, nó k chỉ tạo 1 client mà là nhiều client, VD ta kết nối phát là tạo ra 1 client đầu tiên k gửi request gì cả(chắc là kiểu thiết lập), client thứ 2 tạo ra sẽ yêu cầu lấy directory / ->thì ta gửi file mặc định-> nhưng do browser sẽ load hết các tính năng của HTML nên nó sẽ yêu cầu cả các thứ như file ảnh, âm thanh, file js mỗi cái sẽ tạo ra 1 client mới và gửi request lấy các thứ đó(cứ có 1 file khác đc dùng trong file html kia là nó tạo ra 1 client mới gửi request lấy đúng các file đó->server phải có hết mấy file đó kèm với html để gửi lại).
Trong telnet thì k như v vì chỉ có 1 client duy nhất request mỗi html do nó chỉ biểu diễn html dạng text.

Khi browser gửi request thì nó luôn kết thúc bằng \r\n\r\n nên kiểm tra phải có nó thì mới là request của browser
Vai trò của svr_header: là thừa thãi nếu chạy bằng browser nhưng chạy bằng telnet thì cần bởi vì telnet ta cứ ấn enter liên tục với dữ liệu trống thì đk header.contains(eoh) sẽ kbh đúng. Nếu ta cứ đặt điều kiện như v thì sau 2 lần ấn enter vẫn cái socket đấy nó tự động kết nối vì đã có đủ \r\n\r\n rồi và gửi file mặc định.
Webserver mỗi lần gửi request 1 file mới(file ảnh hay file js,.. đều phải để ở đúng thư mục mà ta trỏ trong file html->chú ý dùng đường dẫn tương đối có thể sai dẫn đến ảnh k load đc nv, kể cả đường dẫn trong HTML), nó sẽ tạo ra 1 socket mới. Và đủ luôn \r\n\r\n nên lấy luôn và svr_header k ảnh hưởng. Nếu svr_header ảnh hưởng làm request bị đổi thì request bị lỗi(request nó gửi là chuẩn đừng có sửa)

Siege là một app giúp ta test web server, nó có thể tạo ra nhiều connection tùy ý cực nhanh để test Ct, hiện các thông số trạng thái các connection.

Nếu ta chỉ có max 8 core chạy 8 thread nhưng ta lại tạo ra 1 app chạy 100 thread cơ thì vẫn chạy đc. Nhưng 100 thread độc lập chạy k khiến Ct tốt hơn vì thực tế nó chia đều 8 thread có thể có cho 100 thread dẫn đến tốc độ mỗi thread bị chậm đi vì nó cố chạy nhảy qua liên tục các thread để đảm bảo chúng đều đang chạy. Chả khác gì dùng 8 thread nhưng lại phức tạp vì ta tạo ra 100 biến thread cho start 1 từ trc. Tốt nhất là dùng đúng số core của máy mặc định sẽ tốt hơn.
