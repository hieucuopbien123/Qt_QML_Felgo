#include "runnabletask.h"

RunnableTask::RunnableTask()
{
    socketDesciptor = 0;
    commandBuffer = "";
}

void RunnableTask::run()
{
    socket = new QTcpSocket();
    /*//ok hiểu thêm về vc truyền đối số this ở đây hay k.
    //Ta luôn có socket là thành viên của class rồi do là biến private nên class xóa là nó cx bị xóa->éo nhé,thế vc truyền
    //đối số đầu vào this ở đây là sai vì liên quan đến thread: ta hiểu là cái biến parent ở đây là runnable là biến
    //ta khởi tạo ở hàm incomning connection bth thì khi thực hiện nó sẽ bay vào trong main thread=>vc truyền vào đối
    //số parent k chỉ là khai báo con trong cha mà còn thể hiện rằng 2 cái đó thưc hiện trong cùng 1 thread.Đương nhiên
    //vì rất nguy hiểm nếu 1 biến bị xóa ở thread này còn 1 biến bị xóa ở thread khác thì lỗi do biến này cần biến kia
    //để khởi tạo, dùng khi ta dùng như này thì nó sẽ đc thực hiện trên 1 thread riêng gọi là threadpool khác với cha là
    //runnable trong main thread nên khai báo this ở đây sẽ báo lỗi->và nó cx éo tự xóa nhé*/
    if(!(socket->setSocketDescriptor(socketDesciptor)))
    {
       qDebug() << "Fail to set socket descriptor";
       return;
    }

    qDebug() << "A new socket is connected";
    connect(socket,SIGNAL(readyRead()),this,SLOT(handleReadyRead()),Qt::DirectConnection);//phải là direct
    connect(socket,SIGNAL(disconnected()),this,SLOT(handleDisconnected()),Qt::DirectConnection);
    connect(socket,SIGNAL(errorOccurred(QAbstractSocket::SocketError)),this,SLOT(getError(QAbstractSocket::SocketError)));

    socket->moveToThread(this->thread());//vì hàm send respond là mainthread k dùng đc socket nên phải..

    QEventLoop loop;
    connect(socket,SIGNAL(disconnected()),&loop,SLOT(quit()));
    loop.exec();//vòng loop này sẽ kéo cái thread trong runnable mãi nhưng là asynchronous nên vẫn thực hiện đc nhiều
    //dù lớn hơn max là 5
}

void RunnableTask::handleReadyRead()
{
    QByteArray content = socket->readAll();
    qDebug() << "Content read: " << content;
    /*//bởi vì bth ta write thì sẽ là gửi đi 1 cục nhưng khi ta thao tác trên cmd thì nó gửi đi từng chữ cái 1-> như v
    //ta phải nhét nó liên tiếp vào 1 string và khi nó kết thúc bằng \n thì mới dừng và chạy lệnh*/
    commandBuffer.append(content);
    if(commandBuffer.endsWith('\n'))
    {
        CommandRequest request;
        request.getRequest(commandBuffer);

        qDebug() << "Your enterd a command";
        emit commandComing(request);
        //C++11 có quy tắc. Với các kiểu dữ liệu cơ bản(QObject kp dữ liệu cơ bản) khi dùng thì: default constructor, copy
        //constructor, move constructor, copy assignment, move assignment and destructor )are generated by default. Nếu ta
        //chủ động tạo thì các default đó sẽ bị xóa hay bị ghi đè lên->Chính vì v ta mới truyền đc int vào hàm mà sử dụng.
        //Do đó ta tạo ra 1 class command request mà k kế thừa QObject-1 class bth ta tự tạo cx coi là 1 kiểu dữ liệu cơ
        //bản và đương nhiên copy constructor sẽ tự có theo mặc định và ta có thể truyền copy vào hàm sử dụng như ở trên có
        //emit commandComing(request); thì request vừa gọi default copy constructor đó. Bh thử thách hơn ta cần dùng signal
        //slot chẳng hạn nên cho CommandRequest kế thừa QObject=> bị lỗi 'call to implicitly deleted copy constructor'
        //Lỗi này là do ta kế thừa từ QObject->QObject có default copy constructor nhưng CommandRequest k còn là kiểu CB nx
        //lại k có nên bị lỗi-> cách fix là tạo ra hẳn 1 copy constructor mới như: CommandRequest(CommandRequest& t){..}
        commandBuffer.clear();
    }
}

void RunnableTask::handleDisconnected()
{
    qDebug() << socket << "is disconnected";
    socket->deleteLater();
}

void RunnableTask::sendResponse(QString response)
{
    if(response == "Goodbye")
        socket->disconnectFromHost();//hàm giúp ngắt kết nối
    socket->write(response.toLatin1());
}

void RunnableTask::getError(QAbstractSocket::SocketError err)
{
    qDebug() << "Error: " << err << ": " << socket->errorString();
}
