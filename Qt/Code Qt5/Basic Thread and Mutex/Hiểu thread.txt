Cho đến h, ta đã biết cách cơ bản để biến 1 hàm chạy trong 1 thread hoạt động độc lập, dùng QMutex, dùng QThread cơ bản, dùng multithread và threadpool cũng như tạo event loop, hiểu bản chất của asynchronous và direct/queue connection, áp dụng nó trong QTcpSocket. Nhưng vẫn chưa gọi là master vì thread có rất nhiều thứ.

Cơ chế: code chạy theo thứ tự từ trên xuống và nằm trong toàn bộ 1 thread app. Đó là khi ta chạy Ct single thread, Vd: chạy 1 Ct hàm main có mainthread, theo thứ tự nó gọi đến 1 hàm của class khác thì hàm đó sẽ add vào mainthread và chạy trong mainthread, nguyên nhân là vì mainthread gọi đến hàm đó, nếu 1 thread khác gọi đến hàm đó thì hàm chạy trong thread khác đó. Nếu Ct chạy multithread thì 2 thread sẽ được chạy đồng thời, xong tùy vào synchronous hay asynchronous mà thực hiện khác nhau. Nếu ta dùng multithread thì cái thread mới sẽ chạy song song theo thứ tự từ trên xuống, nhưng nếu chẳng hạn có signal/slot muốn thread chạy vô hạn->thêm exec() or event loop vào là đc.

Hàm thread của QObject trả về địa chỉ thread mà nó đang chạy cái biến đó. 

Tuy nhiên ta cũng có thể làm cho 1 class đang làm vc ở thread này lại chạy 1 hàm của nó trong 1 thread khác, đó chính là hàm moveToThread dùng để chạy 1 thread độc lập đã biết->Thế này là mọi hàm thread này trong thread khác, nếu chỉ muốn 1 hàm thì connect với signal start thôi. Tuy nhiên nếu ta k chủ động dùng moveToThread hoặc các hình thức khác để khiến cho 1 hàm chạy vào 1 thread khác mà vô tình biến ở thread này ta lại cho nó chạy trong 1 thread khác sẽ gây lỗi. 

Chú ý lỗi: 1 biến ở 1 thread này mà ta cho nó chạy hàm của nó trong 1 thread khác có thể gây lỗi. Vd: ta tạo ra 1 thread task riêng và khởi tạo biến trong nó, như v là hàm run sẽ chạy ở 1 thread độc lập, các biến nào đc khai báo trong hàm run cũng sẽ chạy ở thread độc lập đó, các biến đc khai báo trong các hàm khác thì sẽ chạy trong thread của hàm khác, mà thread đó chính là thread lớn bên ngoài mà cái thread chạy(mainthread)
=>nếu ta khai báo biến trong hàm run, xong cho biến đó chạy hàm ở 1 hàm khác(lúc này hàm khác sẽ chạy ở thread lớn khác với hàm run) thì có thể gây lỗi. Nếu ta thao tác với các widgets cơ bản thì k sao nhưng thao tác với networtk event hay timer thì sẽ báo lỗi nguy hiểm->tốt nhất là dùng đúng hàm của biến nào dùng trong thread chứa biến đó. Xét TH: nếu ta connect signal slot trong hàm run ở TT direct connection với chính cái widgets khai báo trong run phát signal thì ta có thể dùng object đó trong slot vì slot đo thực hiện trong thread của cái phát signal ở đây là cái object đó nên k sao, nhưng queue thì sai về bản chất.

Như v, hàm run được thực hiện trong 1 thread riêng biệt nhưng các signal slot sử dụng bên trong nó thì k, trừ khi ta cố ép dùng direct connection với signal được phát ra bởi 1 con trỏ khai báo trong hàm run. Nếu k, các signal slot sẽ được nhét vào mainthread và thực hiện theo thứ tự và k dùng đc biến của thread hàm run

khi ta tạo biến thread thì biến thread đó nằm trong mainthread. Khi ta tạo biến trong run thì các biến trong run mới chạy trong 1 thread riêng

hiểu bản chất r thì quất hết thread thôi. Xét Vd project 4: ta dùng multithread asynchronous với thread pool. Ta mong muốn mỗi 1 client có thể kết nối đến server độc lập tức là 2 ng cùng kết nối 1 lúc cx ok vì 2 thread khác nhau. Do đó ta tạo socket trong run để nó được khởi tạo độc lập. Ta cũng cần làm gì đó với socket về sau ví dụ chạy hàm gửi cho client chẳng hạn nên các signal đó ta tạo trong hàm run và dùng direct connection. Tuy nhiên ta đâu chỉ gọi hàm của socket trong mấy cái slot đó đâu, ta còn phải gọi ở nhiều hàm khác mà cái task của ta dùng, khi đó thì k thể connect ở run với socket cho các hàm đó đc nên sẽ bị lỗi. Điều này có nh cách để khắc phục:
-> khai báo socket trong hàm khởi tạo của task-> thế thì socket này sẽ đi vào main thread và k thực hiện độc lập. Và cách này cx k ổn vì hàm setsocketDescriptor của socket lại chạy trong run, tức là hàm của thread này chạy trong 1 thread khác sẽ báo lỗi. 
-> gọi moveToThread trong run để dịch cái socket của ta vào mainthread-> thế thì nhiều ng dùng kết nối 1 lúc cx ok nhưng các hàm về sau sẽ thực hiện trong main thread theo thứ tự->chưa hoàn hảo vì ta muốn là mọi thao tác với client đều độc lập ở thread riêng để cả ngàn ng cùng truy cập vào server cũng như server gửi trả thông tin cho cả ngàn ng 1 lúc luôn. 
-> hay là ta moveToThread liên tục, khi có hàm socket dùng ở thread khác thì move sang thread đó, thực hiện xong thì move lại-> k khả thi vì hàm move gọi ở các thread khác thì lại là thực hiện hàm thread này trong thread khác sẽ báo lỗi->có khả thi nhé, tạo 1 biến global lưu thread của run r move qua move lại đc=>k nên
-> hay là ta moveToThread cả cái task đó vào trong thread của run-> k thể vì để move 1 biến vào 1 thread thì thread phải là của 1 biến object nào đó, chứ run là 1 thread ta gọi bên ngoài k của object nào nên k đc.
Bh, ta cần là hàm sendRespond của task gọi đến write của socket thì cái hàm write đó phải thực hiện bởi thread độc lập của hàm run. Muốn v ta phải hiểu làm thế nào để đang từ current thread của mainthread ta lại chạy // nó vs 1 thread khác->đó là chạy hàm run và dùng connect, khi có queue connection nó sẽ chờ về thread kia r thực hiện đồng thời. Như v cái send response kia phải nằm trong 1 slot, slot này thực hiện lệnh trong thread của run-> ta có thể tạo ra 1 cặp signal slot nx, khi cái task phát signal có thông tin đến thì cái socket chạy slot queue connection là write của ta=>phải có 1 class socket kế thừa từ QTcpSocket tạo slot write này=>Đó là hướng hoàn hảo để sử dụng độc lập chứ k cần moveToThread nv: tạo 1 class socket kế thừa từ QTcpSocket và viết slot write cho nó. Sau đó connect khi signal responseToClient đến thì task phát signal sendResponse->connect signal đó với socket slot mới mà ta tạo thì cái hàm write(viết lại từ sendResponse) trở thành 1 hàm của socket nên sẽ thực hiện trong slot của socket=> bc chỉ là biến hàm sendResponse thành hàm của socket để thực hiện cùng thread là xong. Xong cứ hàm nào dùng hàm của socket thì tạo mới như v.
