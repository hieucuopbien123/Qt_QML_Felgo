### TCP
 
Ta sẽ tạo 1 server mới bằng qt multithread, mỗi thread là asynchronous xử lý nh connection.
Expected: ví dụ max 2 connection-> tạo 2 cái telnet kín cả 2-> tạo connection thứ 3-> máy vẫn chạy connection thứ 3 vào 1 trong 2 cái thread(máy sẽ tự xem cái nào rảnh hơn)->dùng 3 connection bth với Ct chỉ có 2 thread->tương tự nhét thêm vào 4,5,.. telnet vẫn chạy(tốc độ hiển nhiên giảm ta có thể set max loading như đã nói bên trên cho mỗi cái thread). Đó chỉ là cơ chế chung của 1 server chứ 1 server k thể chỉ có connect rồi tắt đc, ta sẽ tạo ra 1 server làm 1 chức năng cụ thể nào đó và có tính chất chung multi-connection của server, VD: 1 web servers http.

Mô hình và cách code tốt: Để clean ta tách ra nhiều file khác nhau handle từng cái 1 như trong file mẫu. 
Ta có 1 server để thao tác riêng, server này có 1 biến lưu nhiều connection. Ta dùng biến TCPConnections lưu nhiều connection. Và biến TCPConnection quản lý từng connection 1 vì ta muốn có những hàm riêng của connection().
Server sẽ viết hàm kết nối, thao tác với server(lấy cổng, đóng server,..). Đặc biệt để multiconnection(ta thử tạo ra 1 thread duy nhất quản lý tất cả connection), ta cho listen thì tạo ra 1 thread mới. Và moveToThread biến connections, sau đó cứ có connection thì connections sẽ add connection r thao tác mọi thứ bên trong=> tức là thay vì 1 thread 1 connection, ta tạo 1 list connection r move vào cái thread là thành 1 thread nh connection thôi.
->khai báo biến trong 1 thread thì biến sẽ thuộc về thread và chỉ đc dùng trong thread->nếu khai báo biến ngoài thread, ta dùng moveToThread thì lại thuộc thread ta muốn=>ta muốn cái gì nằm trong thread nào cx đc tùy ý.
Connection sẽ có 1 thành viên là tcp socket, ta viết các hàm thao tác với socket như readyread thì socket làm gì.
Connections sẽ có 1 list biến connection. Ta cho server phát ra có kết nối mới thì connections bắt và tạo ra 1 biến connection mới setSocketDescriptor cho nó r thêm vào list. Ta có thể viết thêm các hàm thao tác với các connection, Ví dụ xóa thì connections sẽ lấy cái connection ra và xóa rồi bỏ khỏi list,..
Clean hơn: ta k nhét tất cả các file đó thành 1 cục .h và .cpp mà ta có thể làm rõ hơn bằng cách tách ra file pri với các server và socket riêng 1 nhóm như v, cái này khác subdir có nhiều file main. Nó như kiểu có nhiều class quá ta tách ra mà thôi. Nhưng các file .h,.cpp gom 1 nhóm phải có .pri để include trong .pro
Trong main ta chỉ cần có server cho listen thôi.
=>Mấy cái kia chỉ là lặt vặt ta biết hết rồi, qtr chỉ là thay vì tạo 1 socket ta tạo 1 list socket rồi move cái list vào thread mà thôi.
(Có 2 cách đó là kế thừa, or tạo biến thành viên. Ở đây ta k kế thừa mà tạo biến thành viên TCPSocket, còn server thì dùng kế thừa)
Để xóa: disconnect socket->bỏ socket khỏi list->xóa socket->(nếu quit) xóa list->quit cái thread(bởi vì thread start k có quit sẽ k dừng)->xóa thread->xóa server.

Chia file để clean code: Áp dụng PP chia nhỏ đã biết, ta làm cho hàm file dialog ez bằng chỉ có hàm listen còn lại ta xử lý trong server do ta tạo. Trong server tối thiểu cần xử lý cái listen và reimplement cái incommingConnection, tức nó phải lắng nghe và xử lý connection mới. Lắng nghe thì nó làm luôn còn xử lý thì ta tạo ra 1 class mới là Connections, truyền vào cho nó để nó xử lý và moveToThread luôn. Trong Connections phải lo vc kết nối và bắt signal slot readyread từng biến QTcpSocket, thế thà ta tạo ra 1 class reimplement cái tcpsocket và xử lý readyread trong nó thế là cả cái list có.
=>nên chia nhỏ vc bằng cách cho 1 class con xử lý và trở thành 1 biến trong class mẹ(đã biết)

Tuy nhiên làm gì có cái server nào mà chỉ kết nối r gửi trả. Cái server này chỉ là 1 cái khung class server có tính chất multi-connection per thread thôi. Ta sẽ ứng dụng để tạo ra 1 http server có tính chất này bằng cách kế thừa.
Tạo class httpserver và httpconnection kế thừa TcpServer và TcpConnection.
HtpServer chính là cái web server. Server thông thường thì client sẽ gửi request và server gửi lại cái gì dựa vào request đó. Nên httpserver sẽ gửi lại client file html. Ta sẽ tạo 1 httpserver như v, và dùng 1 client bằng browser kêt nối với cổng của server lấy ra file html đó và chạy, thao tác với trang web.

http server: phải lưu biến root là địa chỉ thư mục để tìm các file html cần gửi; Ta chỉnh lại hàm incomingConnection dùng biến HttpConnection chứ kp tcp nx. 
Ở trong cái class server đã có connections rồi, ta cho httpserver kế thừa sẽ tự có biến connections k cần implement hàm listen. Ta tạo ra class server chung làm mọi thứ rồi, class http server nếu có gì khác thì reimplement phải có những hàm của server cũ và thêm các code mới.

Http connection kế thừa từ TcpSocket và là socket của server nhận các request của client, thô sơ nhất nó cần xử lý: set mime type; xử lý khi client gửi đến tức readyRead(đó chính là giao thức GET), ta kiểm tra xem nó có hợp lệ là request cho web k(có \r\n)-> hợp lệ thì lấy cái path từ dữ liệu đó ra(cái path của ta sẽ lưu dưới dạng percent encoding khi gửi web request-ta cần lấy url từ kiểu encode đó)-> trong path lấy ra file->nếu file đó là file tồn tại thì socket write cho client cái mã code 200 và gửi file tới cho client, k tồn tại thì write ra 404 Not Found(->chỉ đơn giản như v)
Chú ý: +) Đó chính là bản chất mã lỗi 404 Not Found là cái file ta request ở trong server k tìm thấy.
+)Dữ liệu ta gửi đến là nhiều dòng, mỗi dòng cách nhau bởi \r\n. Dòng đầu tiên chứa METHOD PATH VERSION các nhau bởi space. Các dòng sau là các cặp key-value cách nhau bởi ':'=>ta lấy dòng đầu lấy path là đc->đó là bản chất dữ liệu ta gửi tới webserver
+)Ta dùng biến QMap là m_response và m_request để lưu lại mã code và các giá trị nếu ta cần dùng tới ở chỗ khác.
+)Ta lấy kiểu của file bằng mime type. Ta lấy đuôi file và kiểm tra trong cái list mime type mà ta đã set cho socket có đuôi đó k thì trả ra(k có thì trả ra mặc định octet-stream)
+)Những cái trên là luồng lý tưởng đi theo là chắc chắn đúng nhưng thực tế ta phải làm nhiều thứ lặt vặt khác: như kiểm tra nếu dòng đầu tiên đủ 3 biến METHOD PATH VERSION thì mới thực hiện lưu, kiểm tra nếu file trong path là 1 dir or có dấu hiệu lùi lại ở cấp parent '..' thì phải thay bằng '' ngay vì ta chỉ xét file ở thư mục hiện tại. Ta cx phải kiểm tra nếu request kp là file hợp lệ mà là 1 thư mục thì chưa hẳn là request đó sai, ta gán cho nó 1 file mặc định để gửi cx ok.
+)ta có thể write lại cho client các thông tin mà ta láy được ở file đó như độ dài file, loại file,..

Xử lý transfer rate: ta tách 1 class riêng để làm vc đó, class này có vai trò gửi từ 1 IODevice nguồn đến IODevice đích với 1 tốc độ nhất định do ta kiểm soát. Như v ta cần setDevice nguồn và đích cho nó làm 2 biến. Nó làm đỡ cv cho httpconnection nên gọi nó trong httpconnection khi cần truyền file đó.
(=>Thực chất cái socket hay file đều là iodevice, nó phát signal readyread bất cứ khi nào có dữ liệu. VD biến QFile(kế thừa từ iodevice)ta setFileName cho nó 1 file nào đó thì sẽ readyread và byteWritten cái file đó và có thể gửi file đó đi,còn socket thì gửi cho nó là nó readyread=>bất cứ khi nào có data là readyRead
Bth thì ta cứ readAll và write vào thôi nhưng bh thì ta cần read(<size cần read>) và write(<size cần write>))
Quy trình gửi thô sơ nhất: ta kiểm tra source có byte thì gửi(source read rồi des write luôn) 1 lượng rate->sau đó kiểm tra vẫn còn dữ liệu thì chờ 1 khoảng delay r gửi tiếp(với singelShot)->xong lại kiểm tra có byte thì gửi cho đến hết->quá đơn giản. 
Ta thực hiện gửi trong transfer và kiểm tra delay trong scheduleTransfer. Khi transfer xong 1 lượng max hàm transfer sẽ gọi lại schedule để kiểm tra r lại quay vòng cho đến khi nào gửi hết thì phát signal finish để dừng(k xóa gì cả và client có thể thao tác tiếp với server)
Chú ý: +)Nó quá đơn giản vì chỉ thay vì dùng readAll thì ta dùng read(<size>) để đọc ghi 1 lượng giới hạn.
+)Thực tế ta gọi schedule ở nhiều nơi. readyread gọi vì client lại gửi request gì đó về sau; mặc định vừa chạy phát ta cũng gọi vì nếu server có file dữ liệu hay đc set data từ đầu thì vào phát gửi cái đó đi luôn(hàm start của rateTransfer)
+)Thực tế ta cần kiểm tra khá nhiều: kiểm tra device tồn tại thì mới thực hiện transfer; kiểm tra trạng thái đang transfer thì k transfer nx(1 biến bool isTransfering để lưu); kiểm tra đang trong trạng thái cái timer đang chờ delay thì cx k gửi(các hàm kiểm tra có thể nhét hàm riêng).
+)Thực tế ta k chỉ kiểm tra gửi 1 cục rate như v mà ta sẽ chia nhỏ ra nx với 2 biến rate và size(dùng thế này chuẩn hơn). Còn biến maximum sẽ lưu số lượng byte tổng lớn nhất có thể transfer nếu lơn hơn thì dừng kiểu để chặn trên ý->k cần thiết; biến rate vẫn v là lưu "sau khi gửi 1 lượng rate nào" sẽ thực hiện delay(Trong cùng 1 thread ta k gọi hàm sleep sẽ dừng thread đó lại vì sleep cx là 1 công việc->mà gọi singleShot thì thread đó sẽ rảnh để làm cái khác trong thời gian delay); ta k cho write(rate) mà cho write(size) liên tục, nếu như số lượng byte đã read+size > rate thì sẽ reset cái byte đã read và tiến hành chờ.
+)Đầu ra: ta có 1 biến transfer quản lý quá trình truyền dữ liệu từ iodevice này sang iodevice khác->Dùng nó trong class có 2 iodevice cần truyền. Ta setSource, setDes, setRate, setSize(mỗi lần gửi 1 lượng size, tổng lớn hơn rate thì delay), gọi hàm start(đề phòng có file sẵn thì gửi luôn)=>ta có thể làm chủ quá trình truyền bằng cách cho rateTransfer phát ra các signal trong quá trình đọc như khi nào start, khi nào đang transfer, có lỗi, khi kết thúc thì đóng 2 cái device lại nếu muôn.
=>Vì clean code mà ta mới chia nhỏ cái công việc của class lớn thành nhiều class nhỏ và khai báo biến class nhỏ trong lớn. Nhưng k chỉ v, ta thg cần theo dõi quá trình class nhỏ đi đến đâu, đã làm gì bằng vc phát signal cho class lớn bắt. Class nào cx v, do đó class ratetransfer mới có các signal thao tác với qtr=> nên các class con thực hiện cong vc chia nhỏ đều kế thừa QObject

Projects->File SyStem->right click file->Open in Explore để mở container chứa file
Định nghĩa hàm->ALT+Enter+Enter để khai báo
ALT+Left arrow và ALT+Right arrow  để move giữa 2 file cpp và .h
Ta giảm tốc độ và test tự test xem tốc độ nào là hợp lý
QReadWriteLock sẽ lock cái gì trong quá trình readwrite tránh deadlock->lockForRead()/unlock()
QIODevice có các hàm kiểm tra loại device như isReadable, isSequential. Sequential devices là device chỉ đọc được khi data is available(bytesAvailable) ngược với random-access devices. Nó k có start/end/size/current pos và nó k cho phép seeking con trỏ tới đâu. Ví dụ điển hình của sequential device là network socket. Như v, QIODevice có rất nhiều loại class device kế thừa và isSequential sẽ giúp kiểm tra có phải loại socket or tương tự k.
File có kích thước lớn or rate lớn thì ta dùng qint64 để lưu

Cách dùng socket gửi file cho client với rate xác định: do rate là ta thao tác với từng connection nên khai báo biến trong http connection
Http connection khi có readyread ta đã set nó xử lý request lấy ra 1 cái file rồi
Để sendFile dễ vl: Cho file là source còn socket là des của rate r send như từ source sang des như bth->lấy TT nếu muốn. Chú ý readyRead phát ra khi có data mới vào device tức là 1 khối data mới->khi thêm vào cho nó 1 file nx or ghi tiếp chẳng hạn chứ 1 cục data nó chỉ phát 1 lần. Còn bytesWritten phát ra liên tục khi có data viết vào, tức là 1 cục data 1000KB thì nó phát bytesWritten liên tục trong quá trình luôn. VD: telnet gõ 1 cục dữ liệu ấn enter->socket của server phát readyRead cái cục dữ liệu đó ngay, nhưng cục đó quá lớn bị chia ra làm nhiều phần gửi tới server, readRead cục đó 1 lần nhưng bytesWritten sẽ phát ra nh lần.
=>readyRead phát trc và ta đã lấy đc file rồi. BytesWritten phát sau ta thực hiện sendFile đó từng cục bằng rateTransfer=> kiểm tra code 200 thì mới thực hiện chuyển và remove code sau khi chuyển để tránh sau đó nó nhận request thì 200 vẫn cứ 200 liên tục sẽ sendFile liên tục
Đương nhiên output của ta chỉ cần set cho server cái vị trí file và rate là nó sẽ tự thao tác hết. Tức là cái rate cx có trong server, khi có connection mới thì server sẽ set cho HttpConnection cái rate đó và khi gửi file cái rateTransfer phải set nó là cái rate của connection ta đã set từ trc.

=>Tức là đáng lẽ server phải handle: listen,xử lý request, gửi file, control rate. Ta cho xử lý request bao cả gửi file và control rate. Server chỉ cần listen, httpconnection trong server sẽ xử lý request, rateTransfer trong httpConnecction sẽ gửi file và control rate=>clean code chia các class nhỏ như v=> Thế tức là đâu vào của ta vẫn phải từ cái server listen và có rate, có root file. Nhưng connection và rateTransfer là class con xử lý nên cần truyền nó cho các class con thôi có gì đâu.
Tốc độ rate ta set cho server sẽ ảnh hưởng đến mọi quá trình vd tải trang web, tải nội dung trên trang web vì mọi httpConnection ta đều setRate đó

Để sử dụng server ta có thể dùng telnet open ở cổng 2000 để lấy file html or dùng browser localhost:2000 để truy cập vào trang web. Như v cái lệnh ở đây là gì?
Ta đã xử lý: nếu như request có file thì sẽ gửi file đó. Nếu như k có thì lỗi. Nếu là dir thì gửi file mặc định. Thực chất nếu ta dùng telnet cứ ấn enter thì nó sẽ gửi vào server \r\n mà thôi=>ta tách ra và lấy ra cái path là thư mục root ""=>isDir nên nó sẽ gửi mặc định là file html=>nếu ta dùng telnet gõ theo form đến vị trí file khác thì sẽ nhận đc file khác(nhưng rõ ràng để mặc định là chuẩn rồi vì trong thực tế ta đâu biết cây thư mục của web server có những file nào đâu)
Nếu dùng browser để connect vào cổng 2000 thì khi dùng browser nó sẽ gửi ra 1 request có cấu trúc y như ta đã đoán từ trước, nhưng ta k quan tâm đến các giá trị key-value vì nó có nh thứ phức tạp(thích lấy thì cứ lưu vào m_request), ta chỉ quan tâm đến dòng đầu tiên mặc định sẽ có path là / tức 1 directory hiện tại=>isDir nên sẽ gửi file mặc định luôn. Đương nhiên trong các web server thật sự nó sẽ xử lý cái request đó tỉ mỉ nhưng ở đây ta chỉ bắt các dữ liệu trong request theo cấu trúc và cho nó lấy mặc định thôi.
HTTP/1.1 là version

(Để xem Ct của ta có thể chạy bnh thread có thể dùng QThreadPool ở default sẽ cho ta max số lượng thread pool mà Ct cung cấp=>tùy chất lượng CPU)

Siege là một app giúp ta test web server, nó có thể tạo ra nhiều connection tùy ý cực nhanh để test Ct, hiện các thông số trạng thái các connection.

Nếu ta dùng nhiều thread hơn với thread pool để xử lý 10k connection đi thì mong muốn: là ta set 1 lượng max thread, khi có connection mới thì pool sẽ start nó bằng 1 thread bất kỳ do nó tự lo=> ta tạo biến thread pool và set max cho nó-> tạo class QRunnable chứa 1 list socket luôn vì 1 biến QRunnable là 1 cv mà thread của pool xử lý->ngay hàm listen của server, ta tạo ra số lượng biến con trỏ QRunnable bằng với số lượng thread ta muốn rồi cho pool start nó luôn-> như v là ta có 1 đống thread đã chạy liên tục.(Ở cách cũ là có connection mới là 1 biến QRunnable sinh ra(tức 1 thread mới) và thread này sẽ kết nối với socket đó. Còn bh chưa có connection nào mà chỉ chạy thôi ta đã tạo ra ví dụ 5 thread trống đang start rồi. Mỗi thread lại có 1 biến list connection để xử lý multi connection trong 1 thread)
Bh ta muốn là các connection mới vào sẽ độc lập và hoạt động vào các thread riêng: bắt connection mới bằng cách lấy descriptor của nó-> for cái list QRunnable, nếu gặp QRunnable đang rỗng thì lấy biến QRunnable đó ra-> add cái socket có descriptor kia vào cái list socket của biến QRunnable đang trống. Trống ở đây kp là null mà là nó đang k làm gì cả thì sẽ trống.

Nếu ta chỉ có max 8 core chạy 8 thread nhưng ta lại tạo ra 1 app chạy 100 thread cơ thì vẫn chạy đc. Nhưng 100 thread độc lập chạy k khiến Ct tốt hơn vì thực tế nó chia đều 8 thread có thể có cho 100 thread dẫn đến tốc độ mỗi thread bị chậm đi vì nó cố chạy nhảy qua liên tục các thread để đảm bảo chúng đều đang chạy. Chả khác gì dùng 8 thread nhưng lại phức tạp vì ta tạo ra 100 biến thread cho start 1 từ trc. Tốt nhất là dùng đúng số core của máy mặc định sẽ tốt hơn.
