POC(Proof of Concept): 1 ứng dụng chứng minh tính khả thi của 1 ý tưởng or 1 method nào đó=> giúp cho việc chứng minh 1 ý tưởng gì là đúng, giúp ta đi đúng vào 1 cái hướng có tính thực tiễn, khả thi chứ kp là mãi mãi chỉ là lời nói k thể áp dụng thực tiễn, giúp tăng tính thuyết phục về ý tưởng.
Ví dụ ta nói proof of concept của cái gì tức là ta đang đưa ra những lý lẽ của nó và nó áp dụng trong thực tế khả thi ntn

Server mà ta đã dùng k được áp dụng trong thực tế. Nguyên nhân là vì ta dùng sai, trong javascript họ cũng tư duy như v->đó là mỗi connection 1 thread. 
Ta biết cái thread là 1 thứ rất đắt trong Ct, tài nguyên ở CPU lấy ra dùng cho thread có giới hạn. Do đó các server trong thực tế, họ chạy multithread và mỗi thread lại chạy multi-connection.
Nếu k, giả sử CPU chỉ cho ta sử dụng max là 5 thread, or ta set max thread count là 5 cho thread pool-> nếu có 10 connection thì 5 connection sau sẽ đi vào hàng đợi và phải chờ 5 thg kia kết thúc. Nếu dùng chuẩn thì ta chỉ cần 5 thread đó nhưng mỗi thread lại quản lý hàng trăm connection cơ. 
Đó cũng là cách giải quyết vấn đề C10K-> vấn đề 1 server quản lý 10k connection trong 1 lúc=> đương nhiên k thể tạo 10k thread đc(tùy CPU và RAM). 1 thread xử lý nhiều connection, đó là cách mà các web server nổi tiếng như Apache Server xử lý vấn đề C10K. Bài toán C10K bh đã lên tới hàng triệu 1 connection 1 lúc. Họ k có CPU có pool of hàng triệu thread nhưng họ vẫn có thể xử lý hàng triệu connection.

Để làm đc điều đó phải có giới hạn, ví dụ 1 cái thread của server cho phép 1 client với tốc độ tối đa. Nhưng để dùng 1 thread đó cho multiconnection thì mỗi connection k thể tối đa được mà phải giảm xuống. Ví dụ tốc độ load của client khi kết nối với server max là 1GB/1s nhưng để dùng multithread thì tốc độ chỉ còn là 10MB/1s. Người ta sẽ setup cái giới hạn đó cho mỗi client khi kết nối với server để đảm bảo có thể phục vụ cho 1 số lượng client đủ lớn. Bên trong cái thread chạy asynchronous nên sẽ thực hiện chuyển đổi liên tục xử lý mỗi cái 1 tí theo cơ chế asynchronous chứ k còn xử lý 1 cái nx nên tốc độ xử lý từng cái sẽ giảm dần đi. Vc set max dung lượng sẽ khiến dù server có ít connection đến mấy vẫn ko thể vượt quá đc tốc độ đó. Đến khi TH có quá nhiều connection kết nối cùng 1 lúc vượt qua sự tính toán rằng "mỗi cái 10MB/1s là ổn", khi đó tốc độ của mỗi connection có thể dưới cả 10MB/1s nên ta mới thấy kết nối với cái server này chậm hơn bth.
Như ta đã biết, lập trình multithread asynchronous sẽ do máy tự tính toán. Ví dụ: có max 2 thread a và b đang xử lý 2 công vc, ta muốn thêm 1 công vc thứ 3 thì máy sẽ tự tìm rằng thread đó cái nào rảnh hơn thì sẽ nhét vào thread đó, nó cx tự xử lý trong 1 cái thread có nhiều công vc rằng công vc nào đang trong TT rảnh sẽ thực hiện công vc kia, công vc nào thread cần thực hiện tiếp để sao cho thread đó luôn trong TT làm vc và các cv đc hoàn thành với tốc độ tối ưu. Đó là cơ chế máy xử lý mà ta có học qua trong môn intro. CV của lập trình viên chỉ là set cho Ct chạy multithread asynchronous để nhét CV2 vào thread, còn lại máy tính lo hết.

Cái threadpool+runnable trong cái multithread server của ta cho phép người dùng dùng asynchronous, tức là cái thread đó của ta có thể làm thêm nhiều công vc khác đồng thời khi công vc này có lúc rảnh, nhưng ta lại cho nó cứ mỗi khi có 1 connection mới, thì threadpool lại phải nhả ra 1 thread mới cho nó. Điều này khiến cho thread đó chỉ có 1 nhiệm vụ là xử lý 1 cái connection đó thôi. Xong khi có connection mới thì threadpool full chẳng hạn thì nó sẽ đi vào hàng chờ cái thread kia xong=>tức là threadpool cung cho ta asynchronous và ta có thể dùng 1 thread đó để làm nhiều vc. Thế mà ta lại chỉ dùng thread đó để quản lý mỗi 1 cái connection thì có khác gì synchronous đâu=> cái server đó là sai và k khả thi trong thực tế.
=> tức là cái server của ta vẫn xử lý asynchronous các cv bên trong 1 connection nếu có, nhưng chưa đủ, ta muốn nó xử lý nhiều thread bất đồng bộ mới là chuẩn-> tất cả là do cách code chương trình 1 connection tạo 1 biến con trỏ thread hoàn toàn mới nên mới v.
 
Ta sẽ tạo 1 server mới bằng qt multithread, mỗi thread là asynchronous xử lý nh connection.
Expected: ví dụ max 2 connection-> tạo 2 cái telnet kín cả 2-> tạo connection thứ 3-> máy vẫn chạy connection thứ 3 vào 1 trong 2 cái thread(máy sẽ tự xem cái nào rảnh hơn)->dùng 3 connection bth với Ct chỉ có 2 thread->tương tự nhét thêm vào 4,5,.. telnet vẫn chạy(tốc độ hiển nhiên giảm ta có thể set max loading như đã nói bên trên cho mỗi cái thread). Đó chỉ là cơ chế chung của 1 server chứ 1 server k thể chỉ có connect rồi tắt đc, ta sẽ tạo ra 1 server làm 1 chức năng cụ thể nào đó và có tính chất chung multi-connection của server, VD: 1 web servers http.

Khi có quá nhiều client thì 1 server đơn lẻ k đáp ứng được lượng request khổng lồ-> ng ta sẽ dùng Ct đó với multiserver, VD: facebook có rất nhiều máy chủ trên thế giới. Họ dùng 1 cái load balancer có vai trò phân phối lưu lượng đến 1 nhóm backend server(server pool). Vs cơ chế tương tự, nó tự tính toán xem với yêu cầu mới thêm vào thì server nào sẽ thực hiện để k có server nào bị quá tải và tối ưu về tốc độ và hiệu suất. Nó cx xử lý đc khi 1 máy chủ bị hỏng sẽ chuyển lưu lượng sang các máy chủ còn lại, or 1 máy chủ mới đc thêm vào pool thì sẽ tính toán và sử dụng nó.VD:Cân bằng tải được sử dụng khi website được triển khai trên nhiều hơn một cloud server.

Trong Linux nó coi socket, stdin, stdout, stderr, file đều là file. Và nó giới hạn số lượng file có thể mở(kiểm tra bằng lệnh: ulimit -n) ở 1 con số khá nhỏ tùy vào cấu hình(có thể điều chỉnh)=> nếu ta dùng server với linux thì số lượng socket nó giới hạn chính là số file đó - đi số file đang mở. Để phân biệt giữa các file dùng file descriptor là số nguyên duy nhất được quản lý bởi kernel. 
Tuy nhiên trong window thì số lượng connection có thể tạo là lớn gấp nhiều lần linux, k xét lượng thread mà là lượng tối đa của connection, 1 thread có thể handle nh connection. Đó là do window dùng 1 thứ gọi là IO completion port. Nó là 1 fast and nice model. Vs nó, window quản lý tốt hơn: Nếu ta set 1 số lượng thread vào 1 IO completion port->thì khi có event tới, nó cái port đó sẽ lấy ra 1 thread đc set và xử lý cái event với giới hạn do ta set, nếu k nó sẽ lấy max là số lượng CPU cores. Nếu số lượng thread vượt quá giới hạn thì nó sẽ đợi khi nào có rảnh thì thực hiện. Nhờ IOCP mà xử lý đc vấn đề 1 thread xử lý nh client. Nói chung là nó giúp window xử lý multiple asynchronous IO request. Nó cx là đi với giới hạn socket và file có thể handle nhưng có hàng đợi và mở đc nhiều hơn linux.

Mô hình và cách code tốt: Để clean ta tách ra nhiều file khác nhau handle từng cái 1 như trong file mẫu. 
Ta có 1 server để thao tác riêng, server này có 1 biến lưu nhiều connection. Ta dùng biến TCPConnections lưu nhiều connection. Và biến TCPConnection quản lý từng connection 1 vì ta muốn có những hàm riêng của connection().
Server sẽ viết hàm kết nối, thao tác với server(lấy cổng, đóng server,..). Đặc biệt để multiconnection(ta thử tạo ra 1 thread duy nhất quản lý tất cả connection), ta cho listen thì tạo ra 1 thread mới. Và moveToThread biến connections, sau đó cứ có connection thì connections sẽ add connection r thao tác mọi thứ bên trong=> tức là thay vì 1 thread 1 connection, ta tạo 1 list connection r move vào cái thread là thành 1 thread nh connection thôi.
->khai báo biến trong 1 thread thì biến sẽ thuộc về thread và chỉ đc dùng trong thread->nếu khai báo biến ngoài thread, ta dùng moveToThread thì lại thuộc thread ta muốn=>ta muốn cái gì nằm trong thread nào cx đc tùy ý.
Connection sẽ có 1 thành viên là tcp socket, ta viết các hàm thao tác với socket như readyread thì socket làm gì.
Connections sẽ có 1 list biến connection. Ta cho server phát ra có kết nối mới thì connections bắt và tạo ra 1 biến connection mới setSocketDescriptor cho nó r thêm vào list. Ta có thể viết thêm các hàm thao tác với các connection, Ví dụ xóa thì connections sẽ lấy cái connection ra và xóa rồi bỏ khỏi list,..
Clean hơn: ta k nhét tất cả các file đó thành 1 cục .h và .cpp mà ta có thể làm rõ hơn bằng cách tách ra file pri với các server và socket riêng 1 nhóm như v, cái này khác subdir có nhiều file main. Nó như kiểu có nhiều class quá ta tách ra mà thôi. Nhưng các file .h,.cpp gom 1 nhóm phải có .pri để include trong .pro
Trong main ta chỉ cần có server cho listen thôi.
=>Mấy cái kia chỉ là lặt vặt ta biết hết rồi, qtr chỉ là thay vì tạo 1 socket ta tạo 1 list socket rồi move cái list vào thread mà thôi.
(Có 2 cách đó là kế thừa, or tạo biến thành viên. Ở đây ta k kế thừa mà tạo biến thành viên TCPSocket, còn server thì dùng kế thừa)
Để xóa: disconnect socket->bỏ socket khỏi list->xóa socket->(nếu quit) xóa list->quit cái thread(bởi vì thread start k có quit sẽ k dừng)->xóa thread->xóa server.

Chia file để clean code: Áp dụng PP chia nhỏ đã biết, ta làm cho hàm file dialog ez bằng chỉ có hàm listen còn lại ta xử lý trong server do ta tạo. Trong server tối thiểu cần xử lý cái listen và reimplement cái incommingConnection, tức nó phải lắng nghe và xử lý connection mới. Lắng nghe thì nó làm luôn còn xử lý thì ta tạo ra 1 class mới là Connections, truyền vào cho nó để nó xử lý và moveToThread luôn. Trong Connections phải lo vc kết nối và bắt signal slot readyread từng biến QTcpSocket, thế thà ta tạo ra 1 class reimplement cái tcpsocket và xử lý readyread trong nó thế là cả cái list có.
=>nên chia nhỏ vc bằng cách cho 1 class con xử lý và trở thành 1 biến trong class mẹ(đã biết)

Tuy nhiên làm gì có cái server nào mà chỉ kết nối r gửi trả. Cái server này chỉ là 1 cái khung class server có tính chất multi-connection per thread thôi. Ta sẽ ứng dụng để tạo ra 1 http server có tính chất này bằng cách kế thừa.
Tạo class httpserver và httpconnection kế thừa TcpServer và TcpConnection.
HtpServer chính là cái web server. Server thông thường thì client sẽ gửi request và server gửi lại cái gì dựa vào request đó. Nên httpserver sẽ gửi lại client file html. Ta sẽ tạo 1 httpserver như v, và dùng 1 client bằng browser kêt nối với cổng của server lấy ra file html đó và chạy, thao tác với trang web.

mime type(Multipurpose Internet Mail Extensions): là loại giúp phân loại các tập tin sử dụng trên internet. VD: lúc mới ra đời, thư điện tử chỉ hỗ trợ gửi plaintext, họ dùng mime type là phần mở rộng cho phép email có thể gửi nhận các file có định dạng như video, audio, HTML,.. Hầu hết mọi thư điện tử đều dùng giao thức SMTP theo định dạng MIME. Nhưng ngày nay k chỉ dùng với email, nó cũng dùng trong các máy chủ và trình duyệt để xử lý thông tin. Mime type sẽ giúp specific là loại file gì, vd docx hay jpg,.. VD: ta viết một vài lá thư gửi đi, nhưng mỗi lá thư viết 1 ngôn ngữ khác nhau, mime type sẽ đính vào đầu mỗi lá thư vd "Tiếng Pháp" thì người nhận(client) sẽ nhanh chóng dịch được lá thư đó. VD: khi ta dùng ảnh jpg hay 1 vid cho website bị lỗi mặc dù file vẫn tồn tại trên server=>nguyen nhân chính là do server chưa thêm các mime type của các kiểu dữ liệu đó nên đọc k đc=>server http của ta cần có cac mimetype.
Thành phần mime type gồm: kiểu chính và kiểu phụ. Kiểu chính trước dấu /, kiểu phụ sau dấu đó phù hợp với các định dạng extension tương ứng
VD: text/plain txt thì text kiểu chính còn plain kiểu phụ với file định dạng .txt
Ta cần xác định file ta gửi có các định dạng nào và thêm vào các mime type phù hợp, k có thì Ct k đọc đc. Khi xử lý ta cũng kiểm tra nếu k có thì có thể gửi application/octet-stream là 1 file chứa dữ liệu nhị phân-1 kiểu mimetype mặc định-> Trong Ct này ta dùng mime type chỉ để lấy type của file gửi.

http server: phải lưu biến root là địa chỉ thư mục để tìm các file html cần gửi; Ta chỉnh lại hàm incomingConnection dùng biến HttpConnection chứ kp tcp nx. 
Ở trong cái class server đã có connections rồi, ta cho httpserver kế thừa sẽ tự có biến connections k cần implement hàm listen. Ta tạo ra class server chung làm mọi thứ rồi, class http server nếu có gì khác thì reimplement phải có những hàm của server cũ và thêm các code mới.

Http connection kế thừa từ TcpSocket và là socket của server nhận các request của client, thô sơ nhất nó cần xử lý: set mime type; xử lý khi client gửi đến tức readyRead(đó chính là giao thức GET), ta kiểm tra xem nó có hợp lệ là request cho web k(có \r\n)-> hợp lệ thì lấy cái path từ dữ liệu đó ra(cái path của ta sẽ lưu dưới dạng percent encoding khi gửi web request-ta cần lấy url từ kiểu encode đó)-> trong path lấy ra file->nếu file đó là file tồn tại thì socket write cho client cái mã code 200 và gửi file tới cho client, k tồn tại thì write ra 404 Not Found(->chỉ đơn giản như v)
Chú ý: +) Đó chính là bản chất mã lỗi 404 Not Found là cái file ta request ở trong server k tìm thấy.
+)Dữ liệu ta gửi đến là nhiều dòng, mỗi dòng cách nhau bởi \r\n. Dòng đầu tiên chứa METHOD PATH VERSION các nhau bởi space. Các dòng sau là các cặp key-value cách nhau bởi ':'=>ta lấy dòng đầu lấy path là đc->đó là bản chất dữ liệu ta gửi tới webserver
+)Ta dùng biến QMap là m_response và m_request để lưu lại mã code và các giá trị nếu ta cần dùng tới ở chỗ khác.
+)Ta lấy kiểu của file bằng mime type. Ta lấy đuôi file và kiểm tra trong cái list mime type mà ta đã set cho socket có đuôi đó k thì trả ra(k có thì trả ra mặc định octet-stream)
+)Những cái trên là luồng lý tưởng đi theo là chắc chắn đúng nhưng thực tế ta phải làm nhiều thứ lặt vặt khác: như kiểm tra nếu dòng đầu tiên đủ 3 biến METHOD PATH VERSION thì mới thực hiện lưu, kiểm tra nếu file trong path là 1 dir or có dấu hiệu lùi lại ở cấp parent '..' thì phải thay bằng '' ngay vì ta chỉ xét file ở thư mục hiện tại. Ta cx phải kiểm tra nếu request kp là file hợp lệ mà là 1 thư mục thì chưa hẳn là request đó sai, ta gán cho nó 1 file mặc định để gửi cx ok.
+)ta có thể write lại cho client các thông tin mà ta láy được ở file đó như độ dài file, loại file,..

=>Cách xử lý hiểu những thứ phức tạp là hiểu đc cái luồng thô sơ nhất rằng mọi thứ là lý tưởng, bỏ qua mọi lỗi lặt vặt thì sẽ code rất rất dễ. Ta phải hiểu được bản chất chỉ cần cái gì để làm cái gì mà bỏ qua các cái lặt vặt khác. Đó cx là quy trình làm để hiểu mọi thứ, các thứ lặt vặt như lỗi này lỗi nọ cx chỉ là sau đó ta thêm vào thôi. Đó là kỹ năng đọc code, 1 Ct lớn nhưng ta nhìn ra ngay mấu chốt vấn đề và bỏ qua các thứ kiểm tra lặt vặt.

Xử lý transfer rate: ta tách 1 class riêng để làm vc đó, class này có vai trò gửi từ 1 IODevice nguồn đến IODevice đích với 1 tốc độ nhất định do ta kiểm soát. Như v ta cần setDevice nguồn và đích cho nó làm 2 biến. Nó làm đỡ cv cho httpconnection nên gọi nó trong httpconnection khi cần truyền file đó.
(=>Thực chất cái socket hay file đều là iodevice, nó phát signal readyread bất cứ khi nào có dữ liệu. VD biến QFile(kế thừa từ iodevice)ta setFileName cho nó 1 file nào đó thì sẽ readyread và byteWritten cái file đó và có thể gửi file đó đi,còn socket thì gửi cho nó là nó readyread=>bất cứ khi nào có data là readyRead
Bth thì ta cứ readAll và write vào thôi nhưng bh thì ta cần read(<size cần read>) và write(<size cần write>))
Quy trình gửi thô sơ nhất: ta kiểm tra source có byte thì gửi(source read rồi des write luôn) 1 lượng rate->sau đó kiểm tra vẫn còn dữ liệu thì chờ 1 khoảng delay r gửi tiếp(với singelShot)->xong lại kiểm tra có byte thì gửi cho đến hết->quá đơn giản. 
Ta thực hiện gửi trong transfer và kiểm tra delay trong scheduleTransfer. Khi transfer xong 1 lượng max hàm transfer sẽ gọi lại schedule để kiểm tra r lại quay vòng cho đến khi nào gửi hết thì phát signal finish để dừng(k xóa gì cả và client có thể thao tác tiếp với server)
Chú ý: +)Nó quá đơn giản vì chỉ thay vì dùng readAll thì ta dùng read(<size>) để đọc ghi 1 lượng giới hạn.
+)Thực tế ta gọi schedule ở nhiều nơi. readyread gọi vì client lại gửi request gì đó về sau; mặc định vừa chạy phát ta cũng gọi vì nếu server có file dữ liệu hay đc set data từ đầu thì vào phát gửi cái đó đi luôn(hàm start của rateTransfer)
+)Thực tế ta cần kiểm tra khá nhiều: kiểm tra device tồn tại thì mới thực hiện transfer; kiểm tra trạng thái đang transfer thì k transfer nx(1 biến bool isTransfering để lưu); kiểm tra đang trong trạng thái cái timer đang chờ delay thì cx k gửi(các hàm kiểm tra có thể nhét hàm riêng).
+)Thực tế ta k chỉ kiểm tra gửi 1 cục rate như v mà ta sẽ chia nhỏ ra nx với 2 biến rate và size(dùng thế này chuẩn hơn). Còn biến maximum sẽ lưu số lượng byte tổng lớn nhất có thể transfer nếu lơn hơn thì dừng kiểu để chặn trên ý->k cần thiết; biến rate vẫn v là lưu "sau khi gửi 1 lượng rate nào" sẽ thực hiện delay(Trong cùng 1 thread ta k gọi hàm sleep sẽ dừng thread đó lại vì sleep cx là 1 công việc->mà gọi singleShot thì thread đó sẽ rảnh để làm cái khác trong thời gian delay); ta k cho write(rate) mà cho write(size) liên tục, nếu như số lượng byte đã read+size > rate thì sẽ reset cái byte đã read và tiến hành chờ.
+)Đầu ra: ta có 1 biến transfer quản lý quá trình truyền dữ liệu từ iodevice này sang iodevice khác->Dùng nó trong class có 2 iodevice cần truyền. Ta setSource, setDes, setRate, setSize(mỗi lần gửi 1 lượng size, tổng lớn hơn rate thì delay), gọi hàm start(đề phòng có file sẵn thì gửi luôn)=>ta có thể làm chủ quá trình truyền bằng cách cho rateTransfer phát ra các signal trong quá trình đọc như khi nào start, khi nào đang transfer, có lỗi, khi kết thúc thì đóng 2 cái device lại nếu muôn.
=>Vì clean code mà ta mới chia nhỏ cái công việc của class lớn thành nhiều class nhỏ và khai báo biến class nhỏ trong lớn. Nhưng k chỉ v, ta thg cần theo dõi quá trình class nhỏ đi đến đâu, đã làm gì bằng vc phát signal cho class lớn bắt. Class nào cx v, do đó class ratetransfer mới có các signal thao tác với qtr=> nên các class con thực hiện cong vc chia nhỏ đều kế thừa QObject

Projects->File SyStem->right click file->Open in Explore để mở container chứa file
Định nghĩa hàm->ALT+Enter+Enter để khai báo
ALT+Left arrow và ALT+Right arrow  để move giữa 2 file cpp và .h
Ta giảm tốc độ và test tự test xem tốc độ nào là hợp lý
QReadWriteLock sẽ lock cái gì trong quá trình readwrite tránh deadlock->lockForRead()/unlock()
QIODevice có các hàm kiểm tra loại device như isReadable, isSequential. Sequential devices là device chỉ đọc được khi data is available(bytesAvailable) ngược với random-access devices. Nó k có start/end/size/current pos và nó k cho phép seeking con trỏ tới đâu. Ví dụ điển hình của sequential device là network socket. Như v, QIODevice có rất nhiều loại class device kế thừa và isSequential sẽ giúp kiểm tra có phải loại socket or tương tự k.
File có kích thước lớn or rate lớn thì ta dùng qint64 để lưu

Cách dùng socket gửi file cho client với rate xác định: do rate là ta thao tác với từng connection nên khai báo biến trong http connection
Http connection khi có readyread ta đã set nó xử lý request lấy ra 1 cái file rồi
Để sendFile dễ vl: Cho file là source còn socket là des của rate r send như từ source sang des như bth->lấy TT nếu muốn. Chú ý readyRead phát ra khi có data mới vào device tức là 1 khối data mới->khi thêm vào cho nó 1 file nx or ghi tiếp chẳng hạn chứ 1 cục data nó chỉ phát 1 lần. Còn bytesWritten phát ra liên tục khi có data viết vào, tức là 1 cục data 1000KB thì nó phát bytesWritten liên tục trong quá trình luôn. VD: telnet gõ 1 cục dữ liệu ấn enter->socket của server phát readyRead cái cục dữ liệu đó ngay, nhưng cục đó quá lớn bị chia ra làm nhiều phần gửi tới server, readRead cục đó 1 lần nhưng bytesWritten sẽ phát ra nh lần.
=>readyRead phát trc và ta đã lấy đc file rồi. BytesWritten phát sau ta thực hiện sendFile đó từng cục bằng rateTransfer=> kiểm tra code 200 thì mới thực hiện chuyển và remove code sau khi chuyển để tránh sau đó nó nhận request thì 200 vẫn cứ 200 liên tục sẽ sendFile liên tục
Đương nhiên output của ta chỉ cần set cho server cái vị trí file và rate là nó sẽ tự thao tác hết. Tức là cái rate cx có trong server, khi có connection mới thì server sẽ set cho HttpConnection cái rate đó và khi gửi file cái rateTransfer phải set nó là cái rate của connection ta đã set từ trc.

=>Tức là đáng lẽ server phải handle: listen,xử lý request, gửi file, control rate. Ta cho xử lý request bao cả gửi file và control rate. Server chỉ cần listen, httpconnection trong server sẽ xử lý request, rateTransfer trong httpConnecction sẽ gửi file và control rate=>clean code chia các class nhỏ như v=> Thế tức là đâu vào của ta vẫn phải từ cái server listen và có rate, có root file. Nhưng connection và rateTransfer là class con xử lý nên cần truyền nó cho các class con thôi có gì đâu.
Tốc độ rate ta set cho server sẽ ảnh hưởng đến mọi quá trình vd tải trang web, tải nội dung trên trang web vì mọi httpConnection ta đều setRate đó

Để sử dụng server ta có thể dùng telnet open ở cổng 2000 để lấy file html or dùng browser localhost:2000 để truy cập vào trang web. Như v cái lệnh ở đây là gì?
Ta đã xử lý: nếu như request có file thì sẽ gửi file đó. Nếu như k có thì lỗi. Nếu là dir thì gửi file mặc định. Thực chất nếu ta dùng telnet cứ ấn enter thì nó sẽ gửi vào server \r\n mà thôi=>ta tách ra và lấy ra cái path là thư mục root ""=>isDir nên nó sẽ gửi mặc định là file html=>nếu ta dùng telnet gõ theo form đến vị trí file khác thì sẽ nhận đc file khác(nhưng rõ ràng để mặc định là chuẩn rồi vì trong thực tế ta đâu biết cây thư mục của web server có những file nào đâu)
Nếu dùng browser để connect vào cổng 2000 thì khi dùng browser nó sẽ gửi ra 1 request có cấu trúc y như ta đã đoán từ trước, nhưng ta k quan tâm đến các giá trị key-value vì nó có nh thứ phức tạp(thích lấy thì cứ lưu vào m_request), ta chỉ quan tâm đến dòng đầu tiên mặc định sẽ có path là / tức 1 directory hiện tại=>isDir nên sẽ gửi file mặc định luôn. Đương nhiên trong các web server thật sự nó sẽ xử lý cái request đó tỉ mỉ nhưng ở đây ta chỉ bắt các dữ liệu trong request theo cấu trúc và cho nó lấy mặc định thôi.
HTTP/1.1 là version

Cơ chế: khi ta dùng browser để truy cập vào server, nó k chỉ tạo 1 client mà là nhiều client, VD ta kết nối phát là tạo ra 1 client đầu tiên k gửi request gì cả(chắc là kiểu thiết lập), client thứ 2 tạo ra sẽ yêu cầu lấy directory / ->thì ta gửi file mặc định-> nhưng do browser sẽ load hết các tính năng của HTML nên nó sẽ yêu cầu cả các thứ như file ảnh, âm thanh, file js mỗi cái sẽ tạo ra 1 client mới và gửi request lấy các thứ đó(cứ có 1 file khác đc dùng trong file html kia là nó tạo ra 1 client mới gửi request lấy đúng các file đó->server phải có hết mấy file đó kèm với html để gửi lại).
Trong telnet thì k như v vì chỉ có 1 client duy nhất request mỗi html do nó chỉ biểu diễn html dạng text.

Khi browser gửi request thì nó luôn kết thúc bằng \r\n\r\n nên kiểm tra phải có nó thì mới là request của browser
Vai trò của svr_header: là thừa thãi nếu chạy bằng browser nhưng chạy bằng telnet thì cần bởi vì telnet ta cứ ấn enter liên tục với dữ liệu trống thì đk header.contains(eoh) sẽ kbh đúng. Nếu ta cứ đặt điều kiện như v thì sau 2 lần ấn enter vẫn cái socket đấy nó tự động kết nối vì đã có đủ \r\n\r\n rồi và gửi file mặc định.
Webserver mỗi lần gửi request 1 file mới(file ảnh hay file js,.. đều phải để ở đúng thư mục mà ta trỏ trong file html->chú ý dùng đường dẫn tương đối có thể sai dẫn đến ảnh k load đc nv, kể cả đường dẫn trong HTML), nó sẽ tạo ra 1 socket mới. Và đủ luôn \r\n\r\n nên lấy luôn và svr_header k ảnh hưởng. Nếu svr_header ảnh hưởng làm request bị đổi thì request bị lỗi(request nó gửi là chuẩn đừng có sửa)

(Để xem Ct của ta có thể chạy bnh thread có thể dùng QThreadPool ở default sẽ cho ta max số lượng thread pool mà Ct cung cấp=>tùy chất lượng CPU)

Siege là một app giúp ta test web server, nó có thể tạo ra nhiều connection tùy ý cực nhanh để test Ct, hiện các thông số trạng thái các connection.

Nếu ta dùng nhiều thread hơn với thread pool để xử lý 10k connection đi thì mong muốn: là ta set 1 lượng max thread, khi có connection mới thì pool sẽ start nó bằng 1 thread bất kỳ do nó tự lo=> ta tạo biến thread pool và set max cho nó-> tạo class QRunnable chứa 1 list socket luôn vì 1 biến QRunnable là 1 cv mà thread của pool xử lý->ngay hàm listen của server, ta tạo ra số lượng biến con trỏ QRunnable bằng với số lượng thread ta muốn rồi cho pool start nó luôn-> như v là ta có 1 đống thread đã chạy liên tục.(Ở cách cũ là có connection mới là 1 biến QRunnable sinh ra(tức 1 thread mới) và thread này sẽ kết nối với socket đó. Còn bh chưa có connection nào mà chỉ chạy thôi ta đã tạo ra ví dụ 5 thread trống đang start rồi. Mỗi thread lại có 1 biến list connection để xử lý multi connection trong 1 thread)
Bh ta muốn là các connection mới vào sẽ độc lập và hoạt động vào các thread riêng: bắt connection mới bằng cách lấy descriptor của nó-> for cái list QRunnable, nếu gặp QRunnable đang rỗng thì lấy biến QRunnable đó ra-> add cái socket có descriptor kia vào cái list socket của biến QRunnable đang trống. Trống ở đây kp là null mà là nó đang k làm gì cả thì sẽ trống.

Nếu ta chỉ có max 8 core chạy 8 thread nhưng ta lại tạo ra 1 app chạy 100 thread cơ thì vẫn chạy đc. Nhưng 100 thread độc lập chạy k khiến Ct tốt hơn vì thực tế nó chia đều 8 thread có thể có cho 100 thread dẫn đến tốc độ mỗi thread bị chậm đi vì nó cố chạy nhảy qua liên tục các thread để đảm bảo chúng đều đang chạy. Chả khác gì dùng 8 thread nhưng lại phức tạp vì ta tạo ra 100 biến thread cho start 1 từ trc. Tốt nhất là dùng đúng số core của máy mặc định sẽ tốt hơn.
